<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SFDX Data Dictionary Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root{
            --primary:#007bff;--success:#28a745;--danger:#dc3545;--gray:#6c757d;
            --light:#f8f9fa;--dark:#212529;--border:#dee2e6;--radius:12px;--shadow:0 8px 30px rgba(0,0,0,.1);
        }
        *{box-sizing:border-box;margin:0;padding:0;}
        body{
            font-family:'Inter',sans-serif;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%);
            color:var(--dark);min-height:100vh;display:flex;align-items:center;justify-content:center;padding:16px;
        }
        .container{max-width:960px;width:100%;background:#fff;border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;}
        header{background:var(--primary);color:#fff;padding:24px;text-align:center;}
        h1{margin:0;font-size:1.9rem;font-weight:700;}
        .subtitle{font-size:1rem;opacity:.9;margin-top:6px;}
        .content{padding:32px;}
        .instructions{
            background:#e3f2fd;border-left:4px solid var(--primary);padding:16px;border-radius:8px;
            margin-bottom:24px;font-size:.95rem;
        }
        .instructions h3{margin:0 0 10px;color:var(--primary);}
        .instructions ol{margin:0;padding-left:20px;}
        .instructions li{margin:6px 0;}

        .upload-box{
            border:3px dashed #ccc;border-radius:var(--radius);padding:48px 24px;text-align:center;
            transition:.3s;background:#fafafa;cursor:pointer;position:relative;
        }
        .upload-box:hover,.upload-box.dragover{border-color:var(--primary);background:#f0f8ff;}
        .upload-icon{font-size:48px;color:var(--primary);margin-bottom:12px;}
        .file-input{display:none;}
        .btn{
            display:inline-block;padding:12px 28px;border:none;border-radius:8px;font-weight:600;
            cursor:pointer;transition:.2s;margin-top:16px;
        }
        .btn-primary{background:var(--primary);color:#fff;}
        .btn-primary:hover:not(:disabled){background:#0056b3;transform:translateY(-1px);}
        .btn-primary:disabled{background:#ccc;cursor:not-allowed;}
        .btn-success{background:var(--success);color:#fff;}
        .btn-success:hover:not(:disabled){background:#218838;}

        .progress-container{
            margin-top:20px;padding:16px;background:var(--light);border:1px solid var(--border);
            border-radius:8px;display:none;
        }
        .progress-header{display:flex;justify-content:space-between;align-items:center;font-weight:500;}
        .spinner{
            display:inline-block;width:16px;height:16px;border:2px solid #f3f3f3;
            border-top:2px solid var(--primary);border-radius:50%;animation:spin 1s linear infinite;margin-right:8px;
        }
        @keyframes spin{to{transform:rotate(360deg);}}
        .file-list,.error-list{margin-top:12px;font-size:.9rem;}
        .file-item,.error-item{
            display:flex;align-items:center;padding:4px 0;border-bottom:1px solid #eee;
        }
        .file-item::before{content:"Checkmark";color:var(--success);margin-right:8px;font-weight:bold;}
        .error-item::before{content:"Cross";color:var(--danger);margin-right:8px;}

        footer{text-align:center;padding:20px;color:#888;font-size:.875rem;}
        @media(max-width:600px){.content{padding:20px;} h1{font-size:1.6rem;}}
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>SFDX Data Dictionary</h1>
        <p class="subtitle">SFDX Metadata → Excel (One Sheet Per Object)</p>
    </header>

    <div class="content">
        <div class="instructions">
            <h3>How to Use (SFDX)</h3>
            <ol>
                <li>Use <strong>SFDX</strong> or VS Code to retrieve objects</li>
                <li>Zip the <code>force-app/main/default/objects/</code> folder</li>
                <li>Drag & drop ZIP or individual <code>*.field-meta.xml</code> files</li>
                <li>Click <strong>Generate Excel</strong></li>
            </ol>
        </div>

        <div class="upload-box" id="uploadBox">
            <div class="upload-icon">Folder</div>
            <p><strong>Drag & drop</strong> ZIP or field files here</p>
            <p style="color:#666;font-size:.9rem;">Supports SFDX structure</p>
            <input type="file" id="fileInput" class="file-input" accept=".zip,.xml" multiple>
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                Choose Files
            </button>
        </div>

        <div id="progressContainer" class="progress-container">
            <div class="progress-header">
                <span id="statusText">Ready</span>
                <span id="counter">0 objects</span>
            </div>
            <div id="fileList" class="file-list"></div>
            <div id="errorList" class="error-list"></div>
        </div>

        <div style="text-align:center;margin-top:24px;">
            <button id="generateBtn" class="btn btn-success" disabled onclick="generateExcel()">
                Generate Excel File
            </button>
        </div>
    </div>

    <footer>
        100% Client-Side • SFDX Ready • JSZip + SheetJS
    </footer>
</div>

<script>
/* ========== STATE ========== */
let objectData = {}; // {objectName: {label, description, fields: []}}
let processed = 0, total = 0, errors = 0;

/* ========== DOM ========== */
const uploadBox = document.getElementById('uploadBox');
const fileInput = document.getElementById('fileInput');
const progCont = document.getElementById('progressContainer');
const statusText = document.getElementById('statusText');
const counter = document.getElementById('counter');
const fileList = document.getElementById('fileList');
const errorList = document.getElementById('errorList');
const generateBtn = document.getElementById('generateBtn');

/* ========== DRAG & DROP ========== */
['dragenter','dragover'].forEach(ev=>uploadBox.addEventListener(ev,e=>{e.preventDefault();uploadBox.classList.add('dragover');}));
['dragleave','drop'].forEach(ev=>uploadBox.addEventListener(ev,e=>{e.preventDefault();uploadBox.classList.remove('dragover');}));
uploadBox.addEventListener('drop', e => { if(e.dataTransfer.files.length) handleFiles(e.dataTransfer.files); });
fileInput.addEventListener('change', e => { if(e.target.files.length) handleFiles(e.target.files); });

/* ========== CORE ========== */
function reset() {
    objectData = {}; processed = total = errors = 0;
    fileList.innerHTML = ''; errorList.innerHTML = ''; generateBtn.disabled = true;
    progCont.style.display = 'none';
}
function handleFiles(fileListObj) {
    reset(); const files = Array.from(fileListObj); total = files.length;
    if (!total) return;
    progCont.style.display = 'block';
    statusText.innerHTML = '<div class="spinner"></div> Processing...';
    counter.textContent = '0 objects';
    files[0].name.endsWith('.zip') ? processZip(files[0]) : processIndividualFiles(files);
}

/* ========== ZIP PROCESSING ========== */
async function processZip(zipFile) {
    try {
        const zip = await JSZip.loadAsync(zipFile);
        const entries = [];
        zip.forEach((path, file) => {
            if ((path.endsWith('.object-meta.xml') || path.includes('/fields/')) && !file.dir) {
                entries.push({ path, file });
            }
        });
        if (!entries.length) throw new Error('No object or field files found in ZIP');

        for (const { path, file } of entries) {
            try {
                const content = await file.async('text');
                if (path.endsWith('.object-meta.xml')) {
                    parseObjectFile(path, content);
                } else if (path.includes('/fields/') && path.endsWith('.field-meta.xml')) {
                    parseFieldFile(path, content);
                }
            } catch (e) {
                addError(`Error in ${path.split('/').pop()}: ${e.message}`);
            }
            updateProgress();
        }
    } catch (e) {
        statusText.textContent = 'Error';
        addError(e.message);
    }
}

/* ========== INDIVIDUAL FILES ========== */
function processIndividualFiles(files) {
    files.forEach(f => {
        if (!f.name.endsWith('.xml')) { addError(`Skipped: ${f.name}`); updateProgress(); return; }
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const path = f.name;
                if (path.includes('fields') && path.endsWith('.field-meta.xml')) {
                    parseFieldFile(path, e.target.result);
                } else if (path.endsWith('.object-meta.xml')) {
                    parseObjectFile(path, e.target.result);
                }
            } catch (err) {
                addError(`Parse error in ${f.name}: ${err.message}`);
            }
            updateProgress();
        };
        reader.onerror = () => { addError(`Read error: ${f.name}`); updateProgress(); };
        reader.readAsText(f);
    });
}

/* ========== PARSERS ========== */
function parseObjectFile(path, xmlText) {
    const objectName = extractObjectNameFromPath(path);
    if (!objectName) return;

    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlText, 'text/xml');
    if (doc.querySelector('parsererror')) throw new Error('Invalid XML');

    const label = doc.querySelector('label')?.textContent.trim() || '';
    const description = doc.querySelector('description')?.textContent.trim() || '';

    if (!objectData[objectName]) {
        objectData[objectName] = { label, description, fields: [] };
    } else {
        objectData[objectName].label = label;
        objectData[objectName].description = description;
    }
}

function parseFieldFile(path, xmlText) {
    const objectName = extractObjectNameFromFieldPath(path);
    if (!objectName) return;

    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlText, 'text/xml');
    if (doc.querySelector('parsererror')) throw new Error('Invalid XML');

    const field = {
        'Field Name': doc.querySelector('fullName')?.textContent.trim() || '',
        'Type': doc.querySelector('type')?.textContent.trim() || '',
        'Label': doc.querySelector('label')?.textContent.trim() || '',
        'Description': doc.querySelector('description')?.textContent.trim() || '',
        'Length': doc.querySelector('length')?.textContent.trim() || '',
        'Precision': doc.querySelector('precision')?.textContent.trim() || '',
        'Scale': doc.querySelector('scale')?.textContent.trim() || '',
        'Required': doc.querySelector('required')?.textContent === 'true' ? 'Yes' : 'No',
        'Unique': doc.querySelector('unique')?.textContent === 'true' ? 'Yes' : 'No',
        'Default Value': doc.querySelector('defaultValue')?.textContent.trim() || '',
        'Reference To': doc.querySelector('referenceTo')?.textContent.trim() || ''
    };

    if (!field['Field Name']) return;

    if (!objectData[objectName]) {
        objectData[objectName] = { label: '', description: '', fields: [] };
    }
    objectData[objectName].fields.push(field);
}

/* ========== PATH HELPERS ========== */
function extractObjectNameFromPath(path) {
    // objects/Account/Account.object-meta.xml
    const parts = path.split('/');
    const file = parts.pop();
    if (!file.endsWith('.object-meta.xml')) return null;
    return parts.pop(); // folder name
}

function extractObjectNameFromFieldPath(path) {
    // force-app/main/default/objects/Account/fields/Name.field-meta.xml
    const parts = path.split('/');
    const idx = parts.findIndex(p => p === 'objects');
    if (idx === -1) return null;
    return parts[idx + 1]; // object name after 'objects'
}

/* ========== UI HELPERS ========== */
function addFileItem(name, success) {
    const div = document.createElement('div'); div.className = 'file-item';
    div.innerHTML = `<strong>${name}</strong> — ${success ? 'Loaded' : 'No fields'}`;
    if (!success) div.style.color = '#999';
    fileList.appendChild(div);
}
function addError(msg) {
    errors++;
    const div = document.createElement('div'); div.className = 'error-item';
    div.textContent = msg; errorList.appendChild(div);
}
function updateProgress() {
    processed++;
    const ok = Object.keys(objectData).filter(o => objectData[o].fields.length > 0).length;
    counter.textContent = `${ok} object${ok === 1 ? '' : 's'}`;
    if (processed >= total) {
        setTimeout(() => {
            statusText.textContent = 'Ready';
            generateBtn.disabled = ok === 0;
            Object.keys(objectData).forEach(obj => {
                if (objectData[obj].fields.length > 0) addFileItem(obj, true);
            });
        }, 200);
    }
}

/* ========== EXCEL EXPORT ========== */
function generateExcel() {
    const validObjects = Object.entries(objectData).filter(([_, data]) => data.fields.length > 0);
    if (!validObjects.length) { alert('No fields to export.'); return; }

    generateBtn.disabled = true;
    generateBtn.innerHTML = '<div class="spinner"></div> Building...';

    setTimeout(() => {
        try {
            const wb = XLSX.utils.book_new();
            validObjects.forEach(([objName, data]) => {
                const rows = data.fields.map(f => ({
                    ...f,
                    'Object Label': data.label,
                    'Object Description': data.description
                }));
                const ws = XLSX.utils.json_to_sheet(rows);
                const colW = [];
                rows.forEach(r => Object.values(r).forEach((v, i) => {
                    const len = String(v || '').length;
                    colW[i] = Math.max(colW[i] || 10, len);
                }));
                ws['!cols'] = colW.map(w => ({ wch: w + 2 }));
                XLSX.utils.book_append_sheet(wb, ws, safeName(objName));
            });
            const fname = `SFDX_Data_Dictionary_${new Date().toISOString().slice(0,10)}.xlsx`;
            XLSX.writeFile(wb, fname);
            statusText.textContent = `Downloaded ${fname}`;
        } catch (e) {
            alert('Export failed: ' + e.message);
        } finally {
            generateBtn.disabled = false;
            generateBtn.textContent = 'Generate Excel File';
        }
    }, 50);
}
function safeName(n) { return n.replace(/[\\\/*\[\]:?]/g, '_').substring(0, 31); }
</script>
</body>
</html>
